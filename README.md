# Parlex

Lexer and parser generator tools with core support library.

## Overview

**Parlex** is a suite of Rust-based tools for the generation of efficient lexical analyzers and parsers. The project comprises two complementary crates: **parlex**, the core support library, and **parlex-gen**, which provides the **ALEX** lexer generator and the **ASLR** parser generator. Together, these components form a comprehensive framework for language parsing and analysis.

These tools are inspired by the classic **lex (flex)** and **yacc (bison)** utilities written for C, but provides a **Rust-based implementation**, which is **more composable**, and **improves upon ambiguity resolution**. Unlike lex and yacc, which mix custom user code with automatically generated code, Parlex cleanly separates the two: grammar rules and lexer definitions are named explicitly, and user code refers to them by name.

The **ALEX** lexer generator offers expressive power comparable to that of lex or flex. It leverages Rustâ€™s standard regular expression libraries to construct deterministic finite automata (DFAs) that operate efficiently at runtime to recognize permitted lexical patterns. The system supports multiple lexical states, enabling context-sensitive tokenization.

The **ASLR** parser generator implements the **SLR(1)** parsing algorithm, which is somewhat less general than the **LALR(1)** method employed by yacc and bison. Nevertheless, ASLR introduces a significant enhancement: it supports **dynamic runtime resolution of shift/reduce ambiguities**, offering greater flexibility in domains such as **Prolog**, where operator definitions may be introduced or redefined at runtime.

## Crates

### ðŸ“¦ [parlex](./parlex)

[![Crates.io](https://img.shields.io/crates/v/parlex.svg)](https://crates.io/crates/parlex)
[![Documentation](https://docs.rs/parlex/badge.svg)](https://docs.rs/parlex)
[![License: LGPL-3.0-or-later](https://img.shields.io/badge/License-LGPL%203.0--or--later-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)
[![Rust](https://img.shields.io/badge/rust-stable-brightgreen.svg)](https://www.rust-lang.org)

The core library that defines generic traits and data structures to support lexers and parsers generated by `parlex-gen`. This crate provides:

- Generic traits for lexical analysis and parsing
- Core data structures used by generated code

Generated lexers and parsers depend on this crate. Users build their own custom lexers and parsers based on the generated code, using the traits and data structures defined here.

**Add to your `Cargo.toml`:**
```toml
[dependencies]
parlex = "0.2"
```

### ðŸ”§ [parlex-gen](./parlex-gen)

[![Crates.io](https://img.shields.io/crates/v/parlex-gen.svg)](https://crates.io/crates/parlex-gen)
[![Documentation](https://docs.rs/parlex-gen/badge.svg)](https://docs.rs/parlex-gen)
[![License: LGPL-3.0-or-later](https://img.shields.io/badge/License-LGPL%203.0--or--later-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)
[![Rust](https://img.shields.io/badge/rust-stable-brightgreen.svg)](https://www.rust-lang.org)

The code generation toolset that provides two generators:

- **`alex`**: Regex-based lexer generator for creating tokenizers from lexical specifications
- **`aslr`**: SLR parser generator for building parsers from grammar definitions

Both generators produce code that uses the `parlex` core library.

**Features:**
- Generate regex-based lexers with `alex`
- Generate SLR parsers with `aslr`
- Generated code uses parlex traits and data structures

**Add to your `Cargo.toml`:**
```toml
[build-dependencies]
parlex-gen = "0.2"
```

### ðŸ§® [parlex-calc](./parlex-calc)

[![Crates.io](https://img.shields.io/crates/v/parlex-calc.svg)](https://crates.io/crates/parlex-calc)
[![Documentation](https://docs.rs/parlex-calc/badge.svg)](https://docs.rs/parlex-calc)
[![License: LGPL-3.0-or-later](https://img.shields.io/badge/License-LGPL%203.0--or--later-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)
[![Rust](https://img.shields.io/badge/rust-stable-brightgreen.svg)](https://www.rust-lang.org)

A **sample calculator** built using the `parlex` and `parlex-gen` toolchain.
This crate demonstrates the full workflow of defining, generating, and running a small but complete language processor using **ALEX** and **ASLR**.

#### Highlights

* Implements a complete **expression parser** with arithmetic, identifiers, and assignments
* Shows how to integrate generated lexer and parser code with user-defined driver logic
* Demonstrates **runtime ambiguity resolution** using operator precedence
* Uses a simple **symbol table (`SymTab`)** for variable storage and lookup

#### Components

* **`CalcLexer`** â€” Tokenizes numeric literals, identifiers, operators, parentheses, and separators
* **`CalcParser`** â€” Parses arithmetic expressions, statements, and assignments
* **`CalcLexerDriver` / `CalcParserDriver`** â€” Implement runtime actions for tokenization and parsing
* **`SymTab`** â€” Maintains variable bindings, allowing expressions like `a = 2 + 3; b = a * 10;`
* **`CalcError`** â€” Unified error type covering lexical, parsing, and semantic errors

#### Example

```rust
use parlex_calc::{CalcParser, SymTab};
use try_next::{TryNextWithContext, IterInput};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut symtab = SymTab::new();
    let input = IterInput::from("x = 2 + 3; y = x * 4;".bytes());
    let mut parser = CalcParser::try_new(input)?;
    let results = parser.try_collect_with_context(&mut symtab)?;
    for r in results {
        println!("Parsed: {:?}", r);
    }
    Ok(())
}
```

This example shows how to:

* Create an input stream (`IterInput`)
* Instantiate a parser and shared context (`SymTab`)
* Parse and evaluate multiple statements from the same stream

#### Learning Purposes

The calculator serves as:

* A **reference implementation** of how to connect a lexer and parser generated by Parlex
* A **template project** for building interpreters, DSLs, or scripting languages in Rust
* A demonstration of **end-to-end Parlex integration** with `try_next::TryNextWithContext` streaming APIs


#### Running `parlex-calc` binary

```bash
cargo run -p parlex-calc -- parse <<EOS
/* examples */
x = 2 + 3;
y = x * 4
EOS
```

Prints both the **symbol table (`SymTab`)** and the **parsed token stream**.

```text
[parlex-calc/src/main.rs:58:13] &symtab = SymTab {
    tab: {
        "x": 5,
        "y": 20,
    },
}
[parlex-calc/src/main.rs:59:13] &toks = [
    CalcToken {
        token_id: Stat,
        value: Number(
            5,
        ),
        line_no: 1,
    },
    CalcToken {
        token_id: Stat,
        value: Number(
            20,
        ),
        line_no: 2,
    },
    CalcToken {
        token_id: Stat,
        value: None,
        line_no: 3,
    },
]
```

* Each line is treated as a **separate statement**, terminated by `;`.
* The final standalone `;` produces an **empty statement**, represented as `TokenValue::None`.
* The **symbol table** (`SymTab`) captures the evaluated results of identifiers:

  * `x = 5`
  * `y = 20`

* The **token list** shows one parsed token per statement, plus a final empty statement marker.



## Building & testing

At the repository root:

```bash
cargo build
cargo test
```

You can also build/test an individual crate with `-p`, e.g.:

```bash
cargo test -p parlex
```

## License

Copyright (c) 2005â€“2025 IKH Software, Inc.

Released under the terms of the GNU Lesser General Public License, version 3.0 or (at your option) any later version (LGPL-3.0-or-later).

## Contributing

Contributions are welcome! Please feel free to submit issues or pull requests.
