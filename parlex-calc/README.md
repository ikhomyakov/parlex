# parlex-calc

[![Crates.io](https://img.shields.io/crates/v/parlex-calc.svg)](https://crates.io/crates/parlex-calc)
[![Documentation](https://docs.rs/parlex-calc/badge.svg)](https://docs.rs/parlex-calc)
[![License: LGPL-3.0-or-later](https://img.shields.io/badge/License-LGPL%203.0--or--later-blue.svg)](https://www.gnu.org/licenses/lgpl-3.0)
[![Rust](https://img.shields.io/badge/rust-stable-brightgreen.svg)](https://www.rust-lang.org)

A **sample calculator** built using the `parlex` and `parlex-gen` toolchain.
This crate demonstrates the full workflow of defining, generating, and running a small but complete language processor using **ALEX** and **ASLR**.

## Highlights

* Implements a complete **expression parser** with arithmetic, identifiers, and assignments
* Shows how to integrate generated lexer and parser code with user-defined driver logic
* Demonstrates **runtime ambiguity resolution** using operator precedence
* Uses a simple **symbol table (`SymTab`)** for variable storage and lookup

## Components

* **`CalcLexer`** — Tokenizes numeric literals, identifiers, operators, parentheses, and separators
* **`CalcParser`** — Parses arithmetic expressions, statements, and assignments
* **`CalcLexerDriver` / `CalcParserDriver`** — Implement runtime actions for tokenization and parsing
* **`SymTab`** — Maintains variable bindings, allowing expressions like `a = 2 + 3; b = a * 10;`
* **`CalcError`** — Unified error type covering lexical, parsing, and semantic errors

## Example

```rust
use parlex_calc::{CalcParser, IterInput, SymTab};
use try_next::TryNextWithContext;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let mut symtab = SymTab::new();
    let input = IterInput::from("x = 2 + 3; y = x * 4;".bytes());
    let mut parser = CalcParser::try_new(input)?;
    let results = parser.try_collect_with_context(&mut symtab)?;
    for r in results {
        println!("Parsed: {:?}", r);
    }
    Ok(())
}
```

This example shows how to:

* Create an input stream (`IterInput`)
* Instantiate a parser and shared context (`SymTab`)
* Parse and evaluate multiple statements from the same stream

## Learning Purposes

The calculator serves as:

* A **reference implementation** of how to connect a lexer and parser generated by Parlex
* A **template project** for building interpreters, DSLs, or scripting languages in Rust
* A demonstration of **end-to-end Parlex integration** with `try_next::TryNextWithContext` streaming APIs


## Running `parlex-calc` binary

```bash
cargo run -p parlex-calc -- parse <<EOS
/* examples */
x = 2 + 3;
y = x * 4
EOS
```

Prints both the **symbol table (`SymTab`)** and the **parsed token stream**.

```text
[parlex-calc/src/main.rs:58:13] &symtab = SymTab {
    tab: {
        "x": 5,
        "y": 20,
    },
}
[parlex-calc/src/main.rs:59:13] &toks = [
    CalcToken {
        token_id: Stat,
        value: Number(
            5,
        ),
        line_no: 1,
    },
    CalcToken {
        token_id: Stat,
        value: Number(
            20,
        ),
        line_no: 2,
    },
    CalcToken {
        token_id: Stat,
        value: None,
        line_no: 3,
    },
]
```

* Each line is treated as a **separate statement**, terminated by `;`.
* The final standalone `;` produces an **empty statement**, represented as `TokenValue::None`.
* The **symbol table** (`SymTab`) captures the evaluated results of identifiers:

  * `x = 5`
  * `y = 20`

* The **token list** shows one parsed token per statement, plus a final empty statement marker.



## Building & testing

At the repository root:

```bash
cargo build
cargo test
```


## License

Copyright (c) 2005–2025 IKH Software, Inc.

Released under the terms of the GNU Lesser General Public License, version 3.0 or (at your option) any later version (LGPL-3.0-or-later).

## Contributing

Contributions are welcome! Please feel free to submit issues or pull requests.
